From 65a0f34ada8887de3b9831f21de84e69c9fb96ef Mon Sep 17 00:00:00 2001
From: Chris Sides <christopher.sides@hpe.com>
Date: Thu, 15 Jun 2023 15:56:31 -0500
Subject: [PATCH] DL360 config and early managed FRU handling

---
 configurations/hpe_dl360g10_baseboard.json |   6 +-
 src/fru_device.cpp                         | 156 +++++++++++++++++++++
 2 files changed, 157 insertions(+), 5 deletions(-)

diff --git a/configurations/hpe_dl360g10_baseboard.json b/configurations/hpe_dl360g10_baseboard.json
index 290fa8f..a7be0f9 100644
--- a/configurations/hpe_dl360g10_baseboard.json
+++ b/configurations/hpe_dl360g10_baseboard.json
@@ -312,11 +312,7 @@
         }
     ],
     "Name": "HPE DL360 G10 POC Server",
-    "Probe": [
-        "xyz.openbmc_project.FruDevice({'PRODUCT_MANUFACTURER': 'Hewlett Packard Enterprise'})",
-        "AND",
-        "xyz.openbmc_project.FruDevice({'SERVER_ID': '0x0204'})"
-    ],
+    "Probe": "xyz.openbmc_project.FruDevice({'BoardID': '123'})",
     "Type": "Chassis",
     "xyz.openbmc_project.Inventory.Decorator.Asset": {
         "Manufacturer": "$PRODUCT_MANUFACTURER",
diff --git a/src/fru_device.cpp b/src/fru_device.cpp
index af1155e..477d881 100644
--- a/src/fru_device.cpp
+++ b/src/fru_device.cpp
@@ -1191,6 +1191,160 @@ bool updateFRUProperty(
     return true;
 }
 
+
+
+void addManagedDevices(sdbusplus::asio::object_server& objServer)
+{
+    enum FRUType
+    {
+        gxp = 0,
+        dummy
+    }; 
+
+    //TODO: probably need to add a varaible to allow users to define the 'end of data' character(s) to watch for
+
+    std::map<FRUType, //Key: FRUType, Value: a map of associated directories + a list associated filenames +  field name strings for each
+        std::map<fs::path, //Key: directory path to expected files, Value: paired list of expected filenames + field names associated w/ the directory 
+            std::vector< //list of 'known' files to look for
+                std::pair<fs::path, std::string>>>> managedFRUPaths; //pair<filename, field name>
+
+    managedFRUPaths[FRUType::gxp]["/proc/device-tree/chosen/"] = { {"sn", "serial_number"},
+                                                                    {"pca_sn", "pca_serial_number"},
+                                                                    {"pn", "part_number"},
+                                                                    {"pca_pn", "pca_part_number"},
+                                                                    {"mac_0", "MAC0"},
+                                                                    {"mac_1", "MAC1"} }; 
+    managedFRUPaths[FRUType::gxp]["/sys/class/soc/xreg/"] = { {"xreg/server_id", "server_id"} };
+    //Associated directories, filenames, and field name stings for other FRU types to be handled should be added here
+
+    FRUType typeFound; //set to discovered type when a valid path match is found
+    namespace fs = std::filesystem;
+
+    for (auto managedType : managedFRUPaths)
+    {
+        fs::path directoryPath;
+        FRUType managedFRU;
+
+        //loop through each of the paths managed for a given FRUtype
+        for (auto managedPath : managedType.second)
+        {
+            managedFRU = managedType.first;
+            directoryPath = managedPath.first;
+
+            if (fs::exists(directoryPath))
+            {
+                typeFound = managedFRU;
+                break; //may swap this out later, but for now, let's keep "detect which managed FRU" and "read managed data" as seperate
+                    //we may want to add more complexity to 'detect which FRU' later in the event of other managed devices having similar directory paths
+
+            }
+    
+        }        
+    }
+
+    if (!typeFound)
+    {
+        return; //no valid paths found, so exit
+    }
+
+    std::string manufacturer;
+    switch (typeFound)
+    {
+        case FRUType::gxp:
+            manufacturer= "Hewlett Packard Enterprise";
+            break;
+        default:
+            manufacturer= "Unspecified";
+        break;
+    }
+
+    /*
+    if (typeFound == FRUType::gxp) //manufacturer needs to be manually set for HPE systems at this time...
+    {
+        manufacturer= "Hewlett Packard Enterprise";
+    } */
+
+    std::string interfaceName= typeFound+"FRU";
+    std::shared_ptr<sdbusplus::asio::dbus_interface> iface =
+        objServer.add_interface(interfaceName, "xyz.openbmc_project.FruDevice");
+
+    for(auto managedPath : managedFRUPaths[typeFound])
+    {
+        fs::path directoryPath;
+    
+        directoryPath = managedPath.first; 
+        if (fs::exists(directoryPath))
+        {
+            for (auto knownFile : managedPath.second)
+            {
+                //fs:path fileName = knownFile.first;
+                //TODO: pretty sure I need to modify the path to include filename + directory path!
+                fs::path fullFilePath= directoryPath;
+                fullFilePath += knownFile.first;
+                //fullFilePath+=fileName;
+
+                std::cerr << "ChrisDebug: checking filePath: " <<fullFilePath <<"\n";
+                std::ifstream FRUStream(fullFilePath);
+
+                if (!FRUStream)
+                {
+                    continue; //couldn't open the filepath,so continue on
+                }
+
+                std::string fieldName = knownFile.second;
+                std::string managedFieldData, managedFieldDataLine;
+
+                //bail out if we can't read the dataFile
+                if (!std::getline(FRUStream, managedFieldData))
+                    continue;
+                
+                //TODO: need to add code to shave off the end of file inputs from managedFRU.There's almost always a variable number of 'whitespace' characters 
+
+                //handle for the offchance that there's more than one line of data to be read in
+                while (std::getline(FRUStream, managedFieldDataLine))
+                {
+                    //TODO: need to add code to shave off the end of file inputs from managedFRU.There's almost always a variable number of 'whitespace' characters 
+                    managedFieldData += "\n"+managedFieldDataLine; 
+                }
+
+                iface->register_property(fieldName, managedFieldData);
+            }
+        }
+    }
+
+    //scan for all existing paths.
+    //////unchecked code
+    //std::string FRUInstance = (FRUType)managedFRUPaths[0].second; //temp; == "GxpFRU"
+    
+    
+    //fire this off if files we're checking for exist.
+    //should consider using a map-type setup (like we did for the dbus-sensors modification) to track filepaths to be handled.
+    ///std::string productName =
+    ///    "/xyz/openbmc_project/FruDevice/"+FRUType;
+
+    ///std::shared_ptr<sdbusplus::asio::dbus_interface> iface =
+    ///    objServer.add_interface(productName, "xyz.openbmc_project.FruDevice");
+
+    iface->register_property("BoardID", 123); //Temporary BoardID here for now.
+    //iface->register_property("TestField", "FieldValue Here!");
+/*
+    foreach(auto managedType in mangedFRUPaths)
+    {
+        //managedType.first() is the FRUType maangedType.second() is the list of [assocaited directory paths (string), field name (string)]
+        //iterate through the list of paths associated with the type
+        foreach(auto managedPath in managedType.second())
+        {
+            std::string pathEnd = managedPath.first();
+            std::string fieldName = managedPath.second();
+
+            //need to compare the pathEnd against a list of files found in the directory path.
+        }
+    }
+ */
+    iface->initialize(); 
+    
+}
+
 int main()
 {
     auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
@@ -1333,6 +1487,8 @@ int main()
     rescanBusses(busMap, dbusInterfaceMap, unknownBusObjectCount, powerIsOn,
                  objServer, systemBus);
 
+    addManagedDevices(objServer);
+
     io.run();
     return 0;
 }
